from shapely.geometry import Polygon
from matplotlib.path import Path
import numpy as np
from .setting import *



class MapGenerate():
    
    def __init__(self, obstacles=None, ws=None, margin=0.1):
        self.boundary = ws
        self.obstacles = obstacles # list[np.array shape(4,2) or shape(6,2)]
        self.xy_res = DISCRETE_SIZE
        self.margin = margin
        self.nx = int(np.ceil(np.abs(ws[0, 1] - ws[0, 0]) / self.xy_res))
        self.ny = int(np.ceil(np.abs(ws[1, 1] - ws[1, 0]) / self.xy_res))
        self.sz = np.array([self.nx, self.ny])

        all_inds = np.unravel_index(range(0, self.nx*self.ny),self.sz,order="F")
        ij = np.array(all_inds).T
        
        self.all_pt = self.idx_to_points(ij)
        obs_free_ind = self.is_in_obstacle(self.all_pt, obstacles)

        self.inflated_obstacles = self.inflate_obstacles(self.obstacles, self.margin)
        # obs_free_ind = is_in_obstacle(self.all_pt, self.inflated_obstacles)

        # generate occ map with obs
        occ_map_obs = np.zeros((self.nx, self.ny), dtype=float)
        occ_map_obs_ravel = occ_map_obs.reshape((np.array(occ_map_obs).size, 1), order="F")
        
        
        occ_map_obs_ravel[obs_free_ind == 1] = np.inf
        occ_map_obs = occ_map_obs_ravel.reshape(np.array([self.nx, self.ny]), order="F")
        self.occ_map_obs = occ_map_obs


    def inflate_obstacles(self, obstacles, margin):
        inflated_obstacles = []
        for box in obstacles:
            polygon = Polygon(box)
            inflated_polygon = polygon.buffer(margin)
            inflated_obstacles.append(np.array(inflated_polygon.exterior.coords))
        return inflated_obstacles
    
    
    def idx_to_points(self, ij=None):
        # convert indices in occupancy grid into 3d points xy (Nx3)
        # @input:   self         self generated by load_map
        #           ij         Nx3 indices in self's occupancy grid
        # @output:  xy         Nx3 3d points in actual space
        xy = np.ones((ij.shape[0], 2))
        if ij.shape[0] > 0:
            xy[:, 0] = self.boundary[0, 0] + ij[:, 0] * self.xy_res + self.xy_res * 0.5
            xy[:, 1] = self.boundary[1, 0] + ij[:, 1] * self.xy_res + self.xy_res * 0.5
        else:
            raise Exception('Wrong!')

        return xy
    
    
    def is_in_obstacle(self, ports, obstacles):
        """
        Check if each of the ports is inside any of the obstacles.
        `ports` is a list or array of points, where each point is a 2-element list or array representing the coordinates.
        `obstacles` is a list of obstacles, where each obstacle is represented by a list of its vertex coordinates.
        Returns a boolean array where each element corresponds to whether the respective point is in any obstacle.
        """
        # ports = np.array(ports)
        ports = np.atleast_2d(ports)
        result = np.zeros(len(ports), dtype=bool)
        
        for obstacle in obstacles:
            polygon_path = Path(obstacle)
            result = result | polygon_path.contains_points(ports)
            
        return result